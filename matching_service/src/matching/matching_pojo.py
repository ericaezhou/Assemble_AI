from __future__ import annotations

from pydantic import BaseModel, Field
from enum import Enum
from typing import Any, Dict, List, Optional, Sequence, Tuple

# Type aliases
Vector = Sequence[float]
UserId = str


# --- 1. Enums (REMOVED NeedMatchMode - not needed without needs matching) ---


# --- 2. Core Data Models ---

class UserProfile(BaseModel):
    """
    Simplified user profile model aligned with database schema.

    Focus: Experience and Interest matching only.
    """
    user_id: UserId
    name: str
    role: Optional[str] = "attendee"  # Maps to occupation

    # --- Structured features (for filtering) ---
    tags: List[str] = Field(default_factory=list)  # Parsed from current_skills

    # --- Text fields (for semantic matching) ---
    # These will be composed from database fields:
    # exp_text: from bio + company + title + education
    # interest_text: from interests + research_areas + hobbies
    exp_text: str = ""  # Experience/background text
    interest_text: str = ""  # Interests text

    # --- Vector cache (generated by Adapter) ---
    v_exp: Optional[Vector] = None  # Experience vector
    v_interest: Optional[Vector] = None  # Interest vector
    v_profile: Optional[Vector] = None  # Combined profile vector

    # Optional: debugging/extensions
    metadata: Dict[str, Any] = Field(default_factory=dict)

    def build_profile_text(self) -> str:
        """
        Build unified text for embedding.
        Simplified to only use exp and interest.
        """
        parts: List[str] = []
        if self.exp_text.strip():
            parts.append(f"Experience: {self.exp_text.strip()}")
        if self.interest_text.strip():
            parts.append(f"Interests: {self.interest_text.strip()}")
        if self.tags:
            parts.append("Tags: " + ", ".join(self.tags))
        return "\n".join(parts).strip()


# --- 3. Algorithm Parameters ---

class MatchingParams(BaseModel):
    """
    Simplified algorithm parameters.

    Removed:
    - host_mmr_lambda (host matching simplified)
    - w_goal (no goal field)
    - Needs matching related params
    """
    # --- Host matching parameters ---
    host_recall_top_n: int = 1000  # Recall candidates
    host_return_top_k: int = 100  # Final return count

    # --- Semantic weight distribution ---
    # Only exp and interest (should sum to 1.0)
    w_exp: float = 0.6  # Experience weight
    w_interest: float = 0.4  # Interest weight

    # --- User matching parameters ---
    user_top_k: int = 20  # Top K recommendations per user
    history_penalty: float = 0.8  # Penalty for past matches
    min_score: float = 0.02  # Minimum score threshold

    @classmethod
    def validate_weights(cls, v: 'MatchingParams') -> 'MatchingParams':
        """Validate weight sum"""
        w_sum = v.w_exp + v.w_interest
        if not (0.95 <= w_sum <= 1.05):
            raise ValueError(f"w_exp + w_interest should be ~1.0 (got {w_sum:.3f})")
        return v

    def validate_logic(self) -> None:
        """Cross-field validation"""
        if self.host_recall_top_n < self.host_return_top_k:
            raise ValueError("host_recall_top_n should be >= host_return_top_k")

        w_sum = self.w_exp + self.w_interest
        if not (0.95 <= w_sum <= 1.05):
            raise ValueError(f"w_exp + w_interest should be ~1.0 (got {w_sum:.3f})")


# --- 4. Output Models ---

class MatchRationale(BaseModel):
    """
    LLM-generated match rationale (optional feature).
    """
    summary: str
    highlights: List[str] = Field(default_factory=list)


class RankedUser(BaseModel):
    """Single ranked user result"""
    user_id: UserId
    score: float
    rationale: Optional[MatchRationale] = None
    debug_info: Dict[str, Any] = Field(default_factory=dict)


class UserPair(BaseModel):
    """
    User pair result (for 1v1 matching, optional).
    Simplified - removed mode field.
    """
    user_a: UserId
    user_b: UserId
    score: float
    round_id: int = 1
    rationale: Optional[MatchRationale] = None
    debug_info: Dict[str, Any] = Field(default_factory=dict)

    @property
    def sorted_ids(self) -> Tuple[UserId, UserId]:
        return (self.user_a, self.user_b) if self.user_a < self.user_b else (self.user_b, self.user_a)